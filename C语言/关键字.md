## main

```C
int main(void){}
int main(int argc, char *argv[]){}
int main(int argc, char **argv){}
```
## include

```C
#include <stdio.h>

#include "example.h"
```

## define

- define 作用在预处理阶段，占用编译时间
- 缺点：不检查语法，单纯的替换

```C
#define PI 3.14
```

```C
#define FUN(x) do {                                         \
               ....                                         \
        } while(0);
```

## #static

> 作用于文件
> 自动初始化为0或空值，有记忆效果
> 如果数组参数是多维的，static仅可用于第一维（例如，指定二维数组的行数。）

- 修饰变量
	- 全局（会被局部变量覆盖）
	- 局部
- 修饰函数


## extern

> 说明型(不能改变变量的类型和值)，只能`extern int a`，不能`extern int a = 1`
## register

> 寄存器类型（由编译器决定），只能定义局部变量，不能全局变量；大小有限制，只支持32位大小数据类型。寄存器没有地址，因此无法打印或查看使用地址


## restrict

首先了解下`Pointer aliasing`，是指两个或以上的指针指向同一数据，列如
```C
int i = 0;
int *a = &i;
int *b = &i;

int foo(int *a, int *b) {
	*a = 5;
	*b = 6;
	return *a + *b; // 不一定是11，如果*a,*b指向同一数据，则结果为12
}
```

这样会增加cpu指令操作，每次使用变量都会重新从内存中读取，防止使用时发生修改；
加上`restrict`后，只是告诉编译器这两指针不会指向同一数据（如果相同也不会报错），可以进行指令优化（优化后如果开发人员仍然使两指针指向同一数据，造成的结果是未定义的）；
所以，我们应该尽量避免出现`Pointer aliasing`，遵守契约；

